<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building Your Simulation Model - The QuokkaSim Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The QuokkaSim Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-3-building-your-simulation-model"><a class="header" href="#chapter-3-building-your-simulation-model">Chapter 3: Building your Simulation Model</a></h1>
<p>Now that we've understood the core concepts used by QuokkaSim, let's look at how we assemble a simulation model from scratch.</p>
<ol>
<li>Definitions</li>
<li>Model Assembly</li>
<li>Execution and Logging</li>
</ol>
<p>This chapter will explain the purpose of the specific structs, enums, traits and macros provided by QuokkaSim. Code snippets are also used, but are only for demonstrating individual concepts. Numerous full examples of working simulations can be found in <a href="examples.html">Chapter 4: Examples</a>.</p>
<p>For a video walkthrough of an example simulation, see <a href="https://youtu.be/pyxWDZpzS_c?si=dOU-p8tLJyKbXiMi">QuokkaSim in 18 Minutes | Car Workshop Simulation</a>. Code for this example can be found <a href="https://github.com/jajetloh/quokkasim/blob/main/quokkasim_examples/src/bin/car_workshop.rs">here</a></p>
<hr />
<h1 id="31-initial-setup"><a class="header" href="#31-initial-setup">3.1. Initial Setup</a></h1>
<p>A bare-bones QuokkaSim simulation requires a small amount of boilerplate code to define a number of required enums and macros within your simulation file. A minimal version can be found in <a href="./api_reference.html#definitions-boilerplate">API Reference - Definitions Boilerplate</a>.</p>
<p>Alternatively, we recommend looking through the <a href="./examples.html">list of examples</a>, to find a suitable simulation to use as a starting point.</p>
<h1 id="32-architecting-your-simulation"><a class="header" href="#32-architecting-your-simulation">3.2. Architecting your Simulation</a></h1>
<p>The decision of how to structure your simulation model in terms of QuokkaSim components (and any addditional custom logic) is key.</p>
<p><strong>Resources</strong> in QuokkaSim can be categorised as:</p>
<ul>
<li>
<p><strong>Vector</strong> (or <strong>Continuous</strong>) quantities.</p>
<p>Examples include</p>
<ul>
<li><code>f64</code> to describe a continuous quantity (e.g. mass of material, energy in Joules)</li>
<li><code>Vector3</code> to describe a 3-component continuous quantity (e.g. Iron, Silica and Other mass components in iron ore)</li>
</ul>
</li>
<li>
<p><strong>Discrete</strong> quantities</p>
<p>Examples include</p>
<ul>
<li><code>String</code> to uniquely identify customer arriving at a cafe</li>
<li><code>F64Container</code> to represent a truck with a unique identifier, maximum capacity, and the ability to hold a <code>f64</code> resource</li>
<li><code>Vector3Container</code> to represent a delivery van with a maximum capacity and the ability to hold a <code>Vector3</code> resource with components describing content types</li>
</ul>
</li>
</ul>
<p>A simulation can have any number of distinct Vector and Discrete resources. Using separate resources for different aspects of your model can be beneficial in keeping your simulation clear and maintainable, but there is additional overhead with using separate resources.</p>
<p>Depending on your resource/s, you will require different <code>ComponentModel</code> variants. For a full list of pre-defined components see <a href="./api_reference.html#componentmodel">API Reference - ComponentModel</a>, though you are free and able to define custom compoonents in your own projects.</p>
<h1 id="33-coding-your-simulation"><a class="header" href="#33-coding-your-simulation">3.3. Coding your Simulation</a></h1>
<h1 id="34-semi-custom-components"><a class="header" href="#34-semi-custom-components">3.4. Semi-Custom Components</a></h1>
<h1 id="35-fully-custom-components"><a class="header" href="#35-fully-custom-components">3.5. Fully Custom Components</a></h1>
<!-- 
---

## 3.1. Definitions

### 3.1.1. Enums

A set of four enums comprise the core of QuokkaSim, and these are declared within the **`define_model_enums!`** macro like this:

```rust
define_model_enums! {
    pub enum ComponentModel {}
    pub enum ComponentModelAddress {}
    pub enum ComponentLogger {}
    pub enum ScheduledEvent {}
}
```

Though the enums look empty, `define_model_enums!` endows each of them with all of QuokkaSim's pre-built components, so in reality ComponentModel acts more like this:

```rust
pub enum ComponentModel {
    VectorStockF64(VectorStock<f64>, Mailbox<VectorStock<f64>>),
    VectorProcessF64(VectorProcess<f64>, Mailbox<VectorProcess<f64>>),
    ...
}
```

**`ComponentModel`** is an enum containing all elements we wish to take part in the simulation. Specifically, it must contain all concrete stocks and processes we wish to use. By ensuring that all components are contained as variants in `ComponentModel`, this allows us to later perform much more powerful operations across all components, such as being able to construct a simulation model from a JSON or TOML file.

Each variant contains both the instance of the component, as well as a **`Mailbox`** for the variant. The `Mailbox` a NeXosim struct, and is the single point which receives all inbound communications to the component.

If we wish to use our own custom components, we can register them as variants in `ComponentModel` like this:

```rust
define_model_enums! {
    pub enum ComponentModel {
        MyNewComponent(MyNewComponentStruct, Mailbox<MyNewComponentStruct>),
    }
    pub enum ComponentModelAddress {}
    pub enum ComponentLogger {}
    pub enum ScheduledEvent {}
}
```

**`ComponentModelAddress`** is an enum containing the **`Address`** of all our components. An `Address` is simply a reference to a specific `Mailbox`. While only a single `Mailbox` exists per component, we can get the `Address` from the `Mailbox` and pass ownership and clone as we please. We will use the `Address` to make calls to kick-start the model execution and also to schedule fixed events.

If we wish to use our own custom components, after defining them in `ComponentModel`, the `define_model_enums!` macro creates the corresponding variant in `ComponentModelAddress`, which looks like this. We don't need to manually add them to `ComponentModelAddress`!

```rust
pub enum ComponentModelAddress {
    VectorStockF64(Address<VectorStock<f64>>),
    VectorProcessF64(Address<VectorProcess<f64>>),
    ...
    MyNewComponent(Address<MyNewComponentStruct>),
}
```

**`ComponentLogger`** is an enum containing all unique structs that we wish to be able to collect logs in, and export logs from. QuokkaSim comes pre-built with one type of logger for each standard stock, and each standard process - meaning that all processes (simple processes, splitters, and combiners) for the `Vector3` resource, share the `VectorProcessLoggerVector3` logger, and thus can all export logs into a single file if desired.

Our enums here must contain concrete types (no generic type parameters!), so if we are using our own custom resource, or creating an entirely new `Logger` struct, we must register them like this:

```rust
define_model_enums! {
    pub enum ComponentModel {
        MyNewComponent(MyNewComponentStruct, Mailbox<MyNewComponentStruct>),
    }
    pub enum ComponentModelAddress {}
    pub enum ComponentLogger {
        MyNewVectorLogger(VectorProcessLogger<MyNewResource>), // e.g. adding a new vector resource
        MyNewCustomLogger(MyNewCustomLoggerStruct),            // e.g. adding a new type of Logger
    }
    pub enum ScheduledEvent {}
}
```

Finally, **`ScheduledEvent`** contains all the ways for us to push certain events at select times during the model run, such as a capacity change or a change of distributions. `ScheduledEvent` looks like this:

```rust
pub enum ScheduledEvent {
    SetMaxCapacity(f64),
    SetProcessTime(DistributionConfig),
    ...
}
```

Note that the variants of `ScheduledEvent` aren't tied to a single type of component. This is because we are able to later define for each component, what each of these events means.


<div class="quiz-placeholder" data-quiz-name="&quot;chapter_3_enum_quiz&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;17e96e10-fa47-4f69-9d65-63e8ece13ba3&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;ComponentModel&quot;,&quot;answerIndex&quot;:0},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;ComponentModelAddress&quot;,&quot;ComponentLogger&quot;,&quot;ScheduledEvent&quot;],&quot;prompt&quot;:&quot;Which enum must contain all Processes and Stocks to be used in the model?&quot;}},{&quot;context&quot;:&quot;Components need to be registered in `ComponentModel`, but this automatically creates a corresponding variant in `ComponentModelAddress`. You will also likely want to view logs from the new component, thus a new Logger will also need to be added to `ComponentLogger`.&quot;,&quot;id&quot;:&quot;6428c2ce-e43a-4e10-bfac-e54b4857f57c&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;Manually adding a new variant to `ComponentModel`&quot;,&quot;Manually adding a new variant to `ComponentLogger`&quot;],&quot;answerIndex&quot;:0},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Manually adding a new variant to `ComponentModelAddress`&quot;],&quot;prompt&quot;:&quot;After creating a struct for a custom component, what else needs to happen in `define_model_enums!` to allow it to be used within QuokkaSim?&quot;}}]}"></div>

### 3.1.2. Macros

In addition to defining enums, the `define_model_enums!` macro also defines a number of functions (which are actually macros) that we will use to assemble our model. The fact they are defined within the `define_model_enums!` call means that they are able to work with any custom components and loggers added, and also mean they do not have to be imported via `use` like `define_model_enums!`.

The four functions defined here are:

```rust
fn connect_components!(
    comp1: &mut ComponentModel,
    comp2: &mut ComponentModel,
    n: Option<usize> = None
) { ... }

fn connect_logger!(
    logger: &mut ComponentLogger,
    comp: &mut ComponentModel,
    n: Option<usize> = None
) { ... }

fn register_component!(
    sim_init: SimInit,
    comp: ComponentModel
) -> SimInit { ... }

fn create_scheduled_event!(
    &mut Scheduler,
    MonotonicTime,
    ScheduledEvent,
    ComponentModelAddres,
    &mut DistributionFactory
) { ... }
```

**`connect_components!(&mut comp1, &mut comp2)`** defines a directional relationship, with `comp1` upstream and `comp2` downstream - meaining in this connection, resources flow from `comp1` to `comp2`.

If `comp1` is a splitter, this means there are multiple outputs from `comp1` and we must define which output we wish to connect. **`connect_components!(&mut comp1, &mut comp2, n)`** is how we do this, with `n` being the index of the output from `comp1`.

If `comp2` is a combiner, we have the same problem on the opposite side, where we need to define which input of the combiner we are connecting to. In this case we still use **`connect_components!(&mut comp1, &mut comp2, n)`** but `n` refers to the index of the input for `comp2`.

**`connect_logger!(&mut logger, &mut comp)`** connects a logger to a component. This means that the logger is notified any time the component emits a log from the associated output port. All pre-built QuokkaSim components only have a single output port, though it is possible to create components with multiple ports, with each serving a different purpose.

**`register_component!(sim_init, comp)`** is used to add the instantiated component to the simulation model. This call passes ownership of the component to the `SimInit` instance. Due to some subtleties of the `SimInit` struct, a call to this macro also takes ownership of `SimInit`, and thus must also return `SimInit`. This means usage should always look like this:
```rust
sim_builder = register_component!(sim_builder, process);
```

**`create_scheduled_event!`** creates an event in the global `Scheduler`, which will be triggered at the provided time (this time must be in the future of the current simulation time).

<div class="quiz-placeholder" data-quiz-name="&quot;chapter_3_macro_quiz&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The flow of resources is from the first to second argument, meaning either `stock` pushes or `process` pulls. Stocks are passive and processes are active, so `process` pulling resources in is a more accurate description.&quot;,&quot;id&quot;:&quot;fbb641a5-72de-4574-b816-33a0c706b728&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Allow `process` to pull resources from `stock`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Allow `stock` to pull resources from `process`&quot;,&quot;Allow `stock` to push resources into `process`&quot;,&quot;Allow `process` to push resources into `stock`&quot;],&quot;prompt&quot;:&quot;What does this code do?\n```rust\nconnect_components!(&amp;mut stock, &amp;mut process);\n```\n&quot;}},{&quot;context&quot;:&quot;`connect_logger!` takes a mutable reference to both `logger` and `process` to set up the connection, instead of taking ownership.&quot;,&quot;id&quot;:&quot;79e110b9-7538-42dc-9ff1-47416ea4f050&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`connect_logger!(&amp;mut logger, &amp;mut process)`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`connect_logger!(logger, process);`&quot;,&quot;`connect_logger!(logger, &amp;mut process);`&quot;],&quot;prompt&quot;:&quot;Which is a valid call to `connect_logger`?&quot;}}]}"></div>

## 3.2. Model Assembly

## 3.3. Choose Your Data Structures

QuokkaSim supports the following Resource types out-of-the-box:

- **Vectors (f64)**
  - Use when your quantity of interest is a single number that can take a continuous range of values.
  - e.g. For modelling power consumption, your `f64` can represent Energy in Joules
  - e.g. For modelling material flow, your `f64` can represent payload mass in kg
  - `VectorProcess<f64>`, `VectorStock<f64>` and other similar components can be used out-of-the-box

- **Vectors (Vector3)**
  - Use when your quantity of interest has up to three independent components of interest
  - e.g. For modelling nutrient consumption in crops, your `Vector3` can represent masses of Nitrogen, Phsophorous and Potassium elements
  - e.g. For modelling an iron ore mine, your `Vector3` can represent Iron, Silica and other elements by mass
  - `VectorProcess<Vector3>`, `VectorStock<Vector3>` and other similar components can be used out-of-the-box

- **Sequences (String)**
  - Use when your quantity of interest experiencing queuing or other behaviours dependent on other relative ordering
  - e.g. For modelling a queue of vehicles, your `String` can be a unique identifier for a car

Your simulation can use a combination of these, or you can create your own resources if this suits your use case better (e.g. if you prefer a vector with named entries for readability, instead of referencing components by index).

|| Vectors (f64) | Vectors (Vector3) | Sequences (String) |
|-|-|-|-|
|Resource|`f64`|`Vector3`|`String`|
|Stock|`VectorStock<f64>`|`VectorStock<Vector3>`|`SequenceStock<String>`|
|Process (1-in, 1-out)|`VectorProcess<f64, f64, f64>`|`VectorProcess<Vector3, Vector3, f64>`|`SequenceProcess<Option<String>>`|
|Process (N-in, 1-out)|`VectorCombiner<f64, f64, f64, const M: usize>` | `VectorCombiner<Vector3, Vector3, f64, const M: usize>`| TBC |
|Process (1-in, N-out)|`VectorSplitter<f64, f64, f64, const N: usize>`|`VectorSplitter<Vector3, Vector3, f64, const N: usize>`| TBC |
|Process (0-in, 1-out)|`VectorSource<...>`|`VectorSource<...>`|TBC|
|Process (1-in, 0-out)|`VectorSink<...>`|`VectorSink<...>`|TBC|
|Example use case|Water tanks|Ore movements (using a vector to track elemental composition)|Customers at a Cafe|

**Why so many generic type parameters?**

The pre-defined generic structs `VectorProcess`, `SequenceStock` etc. can be used for any resource your simulation requires - as long as your resource satisfies all trait requirements. These requirements are checked at compiled time by the compiler, so if your code compiles, there's a good chance it will work.

Specifically, for `VectorProcess<T, U, V>`:
- `T` is your resource type
- `U` is the parameter type that is sent by the process to any downstream components, and
- `V` is the parameter type that is sent to upstream components to request material

Thus `VectorProcess<Vector3, Vector3, f64>` is a 1-in, 1-out process which handles a `T=Vector3`, and is passed downstream as a `U=Vector3`. However, when requesting the upstream Stock for material, this process sends a `V=f64` corresponding to the total quantity of desired material, and the stock responds with a `T=Vector3`.

## 3.4. The Core Enums

At the beginning of all the example simulations is a section that looks like this:

```rust
define_model_enums! {
    pub enum ComponentModel {}
    pub enum ComponentLogger {}
    pub enum ComponentInit {}
}

impl CustomComponentConnection for ComponentModel {
    fn connect_components(a: &mut Self, b: &mut Self, n: Option<usize>) -> Result<(), Box<dyn Error>> {
        match (a, b) {
            (a, b) => Err(format!("No component connection defined from {} to {} (n={:?})", a, b, n).into()),
        }
    }
}

impl CustomLoggerConnection for ComponentLogger { 
    type ComponentType = ComponentModel;
    fn connect_logger(a: &mut Self, b: &mut Self::ComponentType, n: Option<usize>) -> Result<(), Box<dyn Error>> {
        match (a, b, n) {
            (a, b, _) => Err(format!("No logger connection defined from {} to {} (n={:?})", a, b, n).into()),
        }
    }
}

impl CustomInit for ComponentInit {
    fn initialise(&mut self, simu: &mut Simulation) -> Result<(), ExecutionError> {
        let notif_meta = NotificationMetadata {
            time: simu.time(),
            element_from: "Init".into(),
            message: "Start".into(),
        };
        match self {
            _ => {
                Err(ExecutionError::BadQuery)
            }
        }
    }
}
```

Let's break down what's going on here

``define_model_enums!`` is a macro provided by QuokkaSim, which is used to help define a number of key Enums that are required. In our examples for clarity they are all named `ComponentModel`, `ComponentLogger` and `ComponentInit` respectively. You are able to choose your own names for each in the body of the macro call, but note the order that they are specified determines the role that each enum plays.

- `ComponentModel` is an Enum whose variants are all possible Stocks and Processes in our model. The `define_model_enums!` macro populates this enum with all of QuokkaSim's pre-built components (e.g. `VectorProcessF64(f64)`, `SequenceStockString(SequenceStock<String>)`).

  If we have our own custom-defined components, we can add them to this enum to register them as a usable component.

- `ComponentLogger` is an Enum whose variants are all possible objects that are able to collect logs from our components, and export these logs.

  If we have our own custom-defined loggers, we can add them to this enum to register them as a usable logger.

- `ComponentInit` is an Enum whose variants are all possible ways that objects should be initialised after model creation, but before the first event.

  If we have our own custom initialisations (for our own components, or custom initialisations for existing components), we can add them to this enum to register them as a usable initialisation.

In addition to these enums, a number of special function macros are also defined in `define_model_enums`.

- `connect_components!` is used to define a connection between two components - typically a Stock and Process, or Process to Stock. In the case where a Process has multiple upstream or downstream stocks, an additional parameter is required to determine the specific upstream or downstream stock that is meant.

- `connect_logger!` is used to define a connection between a component and a logger.

- `register_component!` is used to add the constructed component to the model execution engine.

---

After `define_model_enums!` are a number of trait implementations. These trait implementations are how we define the details of what any sort of 'connection' means. Note that the methods implemented in t hese traits have the same name as the function macros defined in `define_model_enums`. This is because each of our functions here are called within the respective function macros if a pre-defined implementation does not exist for the enum variants passed into the function. -->
<script type="text/javascript" src="quiz\quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz\style.css">
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="examples.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="examples.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
