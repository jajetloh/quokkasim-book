<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The QuokkaSim Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The QuokkaSim Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-quokkasim-book"><a class="header" href="#the-quokkasim-book">The QuokkaSim Book</a></h1>
<p>Welcome to the <strong>QuokkaSim Book</strong> – your guide to learning and mastering QuokkaSim, the Rust-based discrete-event simulation framework.</p>
<blockquote>
<p><strong>Note:</strong><br />
QuokkaSim is under active development. If you find typos or missing features, let JJ know!</p>
</blockquote>
<hr />
<h2 id="what-is-quokkasim"><a class="header" href="#what-is-quokkasim">What is QuokkaSim?</a></h2>
<p>QuokkaSim is a high-performance, event-driven simulation framework written in Rust, on top of the <a href="https://github.com/asynchronics/nexosim">NeXosim</a> simulation engine. It provides:</p>
<ul>
<li>A type-safe <strong>Model</strong> and <strong>Context</strong> API</li>
<li>Monotonic, reproducible <strong>time</strong> scheduling</li>
<li>Pluggable <strong>event handlers</strong> and <strong>plugins</strong></li>
<li>Zero-cost abstractions and minimal runtime overhead</li>
</ul>
<p>Use QuokkaSim to build:</p>
<ul>
<li>Network simulators</li>
<li>Discrete-event process models</li>
<li>Queuing systems and more</li>
</ul>
<hr />
<h2 id="who-should-read-this-book"><a class="header" href="#who-should-read-this-book">Who should read this book?</a></h2>
<p>This book is written for:</p>
<ol>
<li>You</li>
<li>Some other people too</li>
</ol>
<hr />
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<p><strong>Why does QuokkaSim use Rust?</strong></p>
<ul>
<li>Building QuokkaSim in Rust means:
<ul>
<li>QuokkaSim can be free and open source under the MIT License.</li>
<li>QuokkaSim is highly performant (thanks to the <a href="https://github.com/asynchronics/nexosim">NeXosim</a> library).</li>
<li>Simulations built in QuokkaSim can benefit from the type safety, memory safety, and explicit error handling that is fundamental to Rust. This strictness minimises issues that arise as a simulation model scales and increases in complexity.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1-getting-started"><a class="header" href="#chapter-1-getting-started">Chapter 1: Getting Started</a></h1>
<p>Welcome to your first QuokkaSim simulation! In this chapter you will</p>
<ol>
<li>Create a new Rust project</li>
<li>Add QuokkaSim as a dependency</li>
<li>Write and run a minimal "hello world" simulation</li>
</ol>
<hr />
<h2 id="11-create-a-new-rust-project"><a class="header" href="#11-create-a-new-rust-project">1.1. Create a new Rust project</a></h2>
<p>If you don’t already have a project, open a terminal and run:</p>
<pre><code class="language-bash">cargo new hello‐quokkasim
cd hello‐quokkasim
</code></pre>
<p>This creates a fresh binary crate with <code>src/main.rs</code>.</p>
<h2 id="12-add-quokkasim-to-cargotoml"><a class="header" href="#12-add-quokkasim-to-cargotoml">1.2. Add QuokkaSim to Cargo.toml</a></h2>
<p>To add QuokkaSim as a dependency, use <code>cargo add quokkasim</code> or add the following to your <code>Cargo.toml</code> file before running <code>cargo fetch</code>:</p>
<pre><code class="language-toml">[dependencies]
quokkasim = "0.0.1"
</code></pre>
<h2 id="13-write-your-first-simulation"><a class="header" href="#13-write-your-first-simulation">1.3. Write your first Simulation</a></h2>
<p>In your <code>main.rs</code> file, paste in the following code at the top. This imports the required objects, and also creates our <code>ComponentModel</code> and <code>ComponentLogger</code> enums, which we will learn about later.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{error::Error, time::Duration};
use quokkasim::{define_model_enums, prelude::*}; 
use std::fs::create_dir_all;

define_model_enums! {
    pub enum ComponentModel&lt;'a&gt; {}
    pub enum ComponentLogger&lt;'a&gt; {}
}

impl&lt;'a&gt; CustomComponentConnection for ComponentModel&lt;'a&gt; {
    fn connect_components(a: Self, b: Self) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        Err(format!("connect_components not implemented from {} to {}", a, b).into())
    }
}

impl&lt;'a&gt; CustomLoggerConnection&lt;'a&gt; for ComponentLogger&lt;'a&gt; {
    type ComponentType = ComponentModel&lt;'a&gt;;
    fn connect_logger(a: Self, b: Self::ComponentType) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        Err(format!("connect_logger not implemented from {} to {}", a, b).into())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Next we create the individual interactive components of our simulation</p>
<p align="center"><img src="images/fig-01.png" alt="Figure 1: Simulation Overview" /><p>
<p><code>Stock1</code> hold some quantity of material, which <code>Process1</code> moves at specific times, into <code>Stock2</code>. Add the following into the <code>main()</code> function to create these components, and to connect them together.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut stock1 = VectorStock::&lt;f64&gt;::new()
        .with_name("Stock1".to_string())
        .with_low_capacity(5.)
        .with_max_capacity(30.)
        .with_initial_vector(30.);
    let stock1_mbox = Mailbox::new();
    let mut stock1_addr: Address&lt;VectorStock&lt;f64&gt;&gt; = stock1_mbox.address();
    
    let mut process1 = VectorProcess::&lt;f64, f64, f64&gt;::new()
        .with_name("Process1".to_string())
        .with_process_quantity_distr(Distribution::Constant(12.))
        .with_process_time_distr(Distribution::Constant(3.));
    let process_mbox = Mailbox::new();
    let mut process_addr: Address&lt;VectorProcess&lt;f64, f64, f64&gt;&gt; = process_mbox.address();

    let mut stock2 = VectorStock::&lt;f64&gt;::new()
        .with_name("Stock2".to_string())
        .with_low_capacity(15.)
        .with_max_capacity(30.)
        .with_initial_vector(0.);
    let stock2_mbox = Mailbox::new();
    let mut stock2_addr: Address&lt;VectorStock&lt;f64&gt;&gt; = stock2_mbox.address();
    
    ComponentModel::connect_components(
        ComponentModel::VectorStockF64(&amp;mut stock1, &amp;mut stock1_addr),
        ComponentModel::VectorProcessF64(&amp;mut process1, &amp;mut process_addr)
    ).unwrap();
    ComponentModel::connect_components(
        ComponentModel::VectorProcessF64(&amp;mut process1, &amp;mut process_addr),
        ComponentModel::VectorStockF64(&amp;mut stock2, &amp;mut stock2_addr)
    ).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Next we'll add some <code>Logger</code> instances to report on what occurs during the simulation, and connect them to our Process and Stock components.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut stock_logger = VectorStockLogger::&lt;f64&gt;::new("StockLogger".into());
    let mut process_logger = VectorProcessLogger::&lt;f64&gt;::new("ProcessLogger".into());

    ComponentLogger::connect_logger(
        ComponentLogger::VectorStockLoggerF64(&amp;mut stock_logger),
        ComponentModel::VectorStockF64(&amp;mut stock1, &amp;mut stock1_addr)
    ).unwrap();
    ComponentLogger::connect_logger(
        ComponentLogger::VectorStockLoggerF64(&amp;mut stock_logger),
        ComponentModel::VectorStockF64(&amp;mut stock2, &amp;mut stock2_addr)
    ).unwrap();
    ComponentLogger::connect_logger(
        ComponentLogger::VectorProcessLoggerF64(&amp;mut process_logger),
        ComponentModel::VectorProcessF64(&amp;mut process1, &amp;mut process_addr)
    ).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Then we create our <code>Simulation</code> object <code>sim</code>, which controls the progression of the simulation.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let sim_builder = SimInit::new()
        .add_model(stock1, stock1_mbox, "Stock1")
        .add_model(process1, process_mbox, "Process1")
        .add_model(stock2, stock2_mbox, "Stock2");

    let start_time = MonotonicTime::EPOCH;
    let mut sim = sim_builder.init(MonotonicTime::EPOCH).unwrap().0;
<span class="boring">}</span></code></pre></pre>
<p>We send and initialisation events, tell our simulation to run for an hour, and write the resulting logs to CSV files.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    sim.process_event(VectorProcess::update_state, NotificationMetadata {
        element_from: "Init".into(),
        time: start_time.clone(),
        message: "Init".into()
    }, &amp;process_addr).unwrap();
    
    let end_time = start_time + Duration::from_secs(3600);
    sim.step_until(end_time).unwrap();

    let output_dir = "outputs/example_0".to_string();
    create_dir_all(&amp;output_dir).unwrap();
    process_logger.write_csv(output_dir.clone()).unwrap();
    stock_logger.write_csv(output_dir.clone()).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Our <code>main.rs</code> file is now complete (or refer to the Full Code below if you think you're missing something).</p>
<p>Use <code>cargo run</code> to run the simulation, and we have our logs in the <code>outputs/example_0</code> directory!</p>
<hr />
<h2 id="full-code"><a class="header" href="#full-code">Full Code</a></h2>
<pre><pre class="playground"><code class="language-rust no_run">use std::{error::Error, time::Duration};
use quokkasim::{define_model_enums, prelude::*}; 
use std::fs::create_dir_all;

define_model_enums! {
    pub enum ComponentModel&lt;'a&gt; {}
    pub enum ComponentLogger&lt;'a&gt; {}
}

impl&lt;'a&gt; CustomComponentConnection for ComponentModel&lt;'a&gt; {
    fn connect_components(a: Self, b: Self) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        Err(format!("connect_components not implemented from {} to {}", a, b).into())
    }
}

impl&lt;'a&gt; CustomLoggerConnection&lt;'a&gt; for ComponentLogger&lt;'a&gt; {
    type ComponentType = ComponentModel&lt;'a&gt;;
    fn connect_logger(a: Self, b: Self::ComponentType) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        Err(format!("connect_logger not implemented from {} to {}", a, b).into())
    }
}

fn main() {
    
    /*
     * Create components
     */
    let mut stock1 = VectorStock::&lt;f64&gt;::new()
        .with_name("Stock1".to_string())
        .with_low_capacity(5.)
        .with_max_capacity(30.)
        .with_initial_vector(30.);
    let stock1_mbox = Mailbox::new();
    let mut stock1_addr: Address&lt;VectorStock&lt;f64&gt;&gt; = stock1_mbox.address();
    
    let mut process1 = VectorProcess::&lt;f64, f64, f64&gt;::new()
        .with_name("Process1".to_string())
        .with_process_quantity_distr(Distribution::Constant(12.))
        .with_process_time_distr(Distribution::Constant(3.));
    let process_mbox = Mailbox::new();
    let mut process_addr: Address&lt;VectorProcess&lt;f64, f64, f64&gt;&gt; = process_mbox.address();

    let mut stock2 = VectorStock::&lt;f64&gt;::new()
        .with_name("Stock2".to_string())
        .with_low_capacity(15.)
        .with_max_capacity(30.)
        .with_initial_vector(0.);
    let stock2_mbox = Mailbox::new();
    let mut stock2_addr: Address&lt;VectorStock&lt;f64&gt;&gt; = stock2_mbox.address();
    
    ComponentModel::connect_components(
        ComponentModel::VectorStockF64(&amp;mut stock1, &amp;mut stock1_addr),
        ComponentModel::VectorProcessF64(&amp;mut process1, &amp;mut process_addr)
    ).unwrap();
    ComponentModel::connect_components(
        ComponentModel::VectorProcessF64(&amp;mut process1, &amp;mut process_addr),
        ComponentModel::VectorStockF64(&amp;mut stock2, &amp;mut stock2_addr)
    ).unwrap();
    
    /*
     * Create loggers
     */
    let mut stock_logger = VectorStockLogger::&lt;f64&gt;::new("StockLogger".into());
    let mut process_logger = VectorProcessLogger::&lt;f64&gt;::new("ProcessLogger".into());

    ComponentLogger::connect_logger(
        ComponentLogger::VectorStockLoggerF64(&amp;mut stock_logger),
        ComponentModel::VectorStockF64(&amp;mut stock1, &amp;mut stock1_addr)
    ).unwrap();
    ComponentLogger::connect_logger(
        ComponentLogger::VectorStockLoggerF64(&amp;mut stock_logger),
        ComponentModel::VectorStockF64(&amp;mut stock2, &amp;mut stock2_addr)
    ).unwrap();
    ComponentLogger::connect_logger(
        ComponentLogger::VectorProcessLoggerF64(&amp;mut process_logger),
        ComponentModel::VectorProcessF64(&amp;mut process1, &amp;mut process_addr)
    ).unwrap();

    /*
     * Build simulation
     */
    let sim_builder = SimInit::new()
        .add_model(stock1, stock1_mbox, "Stock1")
        .add_model(process1, process_mbox, "Process1")
        .add_model(stock2, stock2_mbox, "Stock2");

    let start_time = MonotonicTime::EPOCH;
    let mut sim = sim_builder.init(MonotonicTime::EPOCH).unwrap().0;

    /*
     * Run simulation
     */
    sim.process_event(VectorProcess::update_state, NotificationMetadata {
        element_from: "Init".into(),
        time: start_time.clone(),
        message: "Init".into()
    }, &amp;process_addr).unwrap();
    
    let end_time = start_time + Duration::from_secs(3600);
    sim.step_until(end_time).unwrap();

    let output_dir = "outputs/example_0".to_string();
    create_dir_all(&amp;output_dir).unwrap();
    process_logger.write_csv(output_dir.clone()).unwrap();
    stock_logger.write_csv(output_dir.clone()).unwrap();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-a-conceptual-overview"><a class="header" href="#chapter-2-a-conceptual-overview">Chapter 2: A Conceptual Overview</a></h1>
<p>In Chapter 1 we ran some code for our first simulation, but now we'll try to cover the core concepts used for modelling in QuokkaSim, before we look again at the code to understand better what's happening.</p>
<hr />
<h2 id="21-discrete-event-simulation-and-the-schedule"><a class="header" href="#21-discrete-event-simulation-and-the-schedule">2.1. Discrete Event Simulation and the Schedule</a></h2>
<p>Simulations answer "what-if" questions, most commonly about what is the result of a set of initial conditions, rules, and controls.</p>
<p>One approach is to approximate the continuous flow of time, by simulating the system at regular time-steps. This is a good regime for modelling continuous processes, such as:</p>
<ul>
<li>Movement of a pendulum under gravity,</li>
<li>Temperature of a room over a day, or</li>
<li>Stresses and fatigue in a beam under repeated loads</li>
</ul>
<p>A time-stepped approach is good in these cases because</p>
<ol>
<li>There are well-defined equations for how quantities of interest change over time</li>
<li>The length of the time-step can be adjusted based on how precise results need to be (and in fact, some approaches <a href="https://en.wikipedia.org/wiki/Adaptive_step_size">use an adaptive, changing time-step</a>)</li>
</ol>
<p>In each of the above situations, quantities of interest change continuously over time, so we need to re-calculate the state of the system often to ensure we're capturing any important changes.</p>
<p>However, many systems don't deal with continuous quantities, or have important behaviour happening continuously over time, for example:</p>
<ul>
<li>Traffic flow through a traffic light,</li>
<li>Preparing drinks at a cafe, or</li>
<li>Car assembly at a factory</li>
</ul>
<p>In these situations, it can be very inefficient to update every component of the system at every timestep. A better approach here is to only update the system at the exact timesteps where something will happen! This is the approach taken in Discrete Even Simulation.</p>
<p>In Discrete Event Simulation, an ordered schedule of events is maintained, and time jumps forward to the next event, which in turns can schedule more events.</p>
<h2 id="22-resources-stocks-and-processes"><a class="header" href="#22-resources-stocks-and-processes">2.2. Resources, Stocks and Processes</a></h2>
<p>TL;DR:</p>
<ul>
<li>Resources are the quantities of stuff that we're interested in the movement of</li>
<li>Stocks are entities which passively hold resources</li>
<li>Processes are entities which actively move or transform resources, and can hold some resources as part of processing</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Example Use Case</th><th>Resource</th><th>Stocks</th><th>Processes</th></tr></thead><tbody>
<tr><td>Water tanks connected by pipes</td><td>Litres of water</td><td>Tanks, resevoirs, pipes</td><td>Valves</td></tr>
<tr><td>Trucking of Ore</td><td>Tonnes of ore</td><td>Stockpiles of ore</td><td>Trucks, conveyors, reclaiming equipment</td></tr>
<tr><td>Customers in a Cafe</td><td>Customers</td><td>Queue for ordering, waiting area</td><td>Taking orders, serving drinks</td></tr>
</tbody></table>
</div>
<h2 id="23-detailed-material-flow-customers-in-a-cafe"><a class="header" href="#23-detailed-material-flow-customers-in-a-cafe">2.3. Detailed Material Flow: Customers in a Cafe</a></h2>
<p><strong>Time = Initial</strong></p>
<p align="center"><img src="images/barista_1.svg" alt="Barista 1" /><p>
We have a stock representing a queue of customers, which is processed by a barista who takes drink orders, before customers go into another queue to wait for their drink. The starting point of the simulation is shown in the diagram, with 3 people in line, and 1 person waiting for their drink.
<p>Remember that Discrete Event Simulations rely on scheduled events triggering more events. There are no events at the start of the simulation, so we kick-start the simulation at the start by telling our Process to update its own state.</p>
<p><strong>Time = 0:00</strong></p>
<p align="center"><img src="images/barista_2.svg" alt="Barista 2" /><p>
<p>The barista can only process a customer if a customer is in the queue, and if there is sufficient room in the waiting area (or perhaps just to not overwhelm the baristas who are making the drinks).</p>
<p>So first, the process retrieves the current state of the upstream stock (Queued Customers) and downstream stock (Waiting for drinks). For now, stocks can have one of three states: Empty, Normal and Full.</p>
<p>Queued customers is Full and Waiting for drinks is Normal. In this case, the barista can take an order, so the process seizes the front-most customer from the queue, and schedules a new event to occur in 30 seconds, when the ordering is complete.</p>
<p><strong>Time = 0:30</strong></p>
<p align="center"><img src="images/barista_3.svg" alt="Barista 3" /><p>
<p>30 seconds later, the event triggers <em>Barista taking orders</em> is prompted to update itself again. This time, it first moves Customer B moves into the <em>Waiting for drinks</em> stock, before checking upstream and downstream states again. This time both states are <em>Normal</em>, in which case the process seizes the next customer and repeats.</p>
<p align="center"><img src="images/barista_4.svg" alt="Barista 4" /><p>
<p><strong>Time = 1:00</strong></p>
<p align="center"><img src="images/barista_5.svg" alt="Barista 5" /><p>
<p><em>Barista taking orders</em> is again triggered to update its state, and moves C into <em>Waiting for drinks</em>. This time the upstream and downstream states are <em>Normal</em> and <em>Full</em>. Because downstream is full, we do not process the next customer, and instead wait until we are triggered to update again.</p>
<p><strong>Time = 1:15</strong></p>
<p align="center"><img src="images/barista_6.svg" alt="Barista 6" /><p>
<p><em>Waiting for drinks</em> has reduced from 3 people to 1 person, meaning its state has changed from <em>Full</em> to <em>Empty</em>. This change of state triggers any upstream or downstream processes to update, meaning that <em>Barista taking orders</em> is triggered to update.</p>
<p><em>Barista taking orders</em> checks both upstream and downstream state again, finds both are <em>Normal</em>, so then begins processing D.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-a-basic-simulation-model"><a class="header" href="#chapter-3-a-basic-simulation-model">Chapter 3: A Basic Simulation Model</a></h1>
<p>Now that we've understood the core concepts used by QuokkaSim, let's look at how we assemble a simple simulation model from scratch.</p>
<hr />
<h2 id="31-choose-your-data-structures"><a class="header" href="#31-choose-your-data-structures">3.1. Choose Your Data Structures</a></h2>
<p>QuokkaSim supports the following Resource types out-of-the-box:</p>
<ul>
<li>
<p><strong>Vectors (f64)</strong></p>
<ul>
<li>Use when your data can be represented as simple numeric quantities.</li>
<li>Example: <code>VectorStock&lt;f64&gt;</code> tracks quantities like capacity, consumption, or other scalar values.</li>
</ul>
</li>
<li>
<p><strong>Vectors (Vector3)</strong></p>
<ul>
<li>Use when your simulation involves multi-dimensional data (for example, spatial coordinates or RGB color channels).</li>
<li>Example: <code>VectorStock&lt;Vector3&gt;</code> is great for modeling 3D measurements.</li>
</ul>
</li>
<li>
<p><strong>Sequences (String)</strong></p>
<ul>
<li>Use for models where data is represented as sequences or lists of identifiers.</li>
<li>Example: <code>SequenceStock&lt;String&gt;</code> is useful for handling events or discrete item identifiers.</li>
</ul>
</li>
</ul>
<p>Your simulation can use a combination of these, or you can create your own resources if this suits your use case better (e.g. if you prefer a vector with named entries for readability, instead of referencing components by index).</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Vectors (f64)</th><th>Vectors (Vector3)</th><th>Sequences (String)</th></tr></thead><tbody>
<tr><td>Resource</td><td><code>f64</code></td><td><code>Vector3</code></td><td><code>String</code></td></tr>
<tr><td>Stock</td><td><code>VectorStock&lt;f64&gt;</code></td><td><code>VectorStock&lt;Vector3&gt;</code></td><td><code>SequenceStock&lt;String&gt;</code></td></tr>
<tr><td>Process (1-in, 1-out)</td><td><code>VectorProcess&lt;f64, f64, f64&gt;</code></td><td><code>VectorProcess&lt;Vector3, Vector3, f64&gt;</code></td><td><code>SequenceProcess&lt;Option&lt;String&gt;&gt;</code></td></tr>
<tr><td>Process (N-in, 1-out)</td><td>TBC</td><td>TBC</td><td>TBC</td></tr>
<tr><td>Process (1-in, N-out)</td><td>TBC</td><td>TBC</td><td>TBC</td></tr>
<tr><td>Example use case</td><td>Water tanks</td><td>Ore movements (using a vector to track elemental composition)</td><td>Customers at a Cafe</td></tr>
</tbody></table>
</div>
<p><strong>Why so many generic type parameters?</strong></p>
<p>The pre-defined generic structs <code>VectorProcess</code>, <code>SequenceStock</code> etc. can be used for any resource your simulation requires - as long as your resource satisfies all trait requirements. These requirements are checked at compiled time by the compiler, so if your code compiles, there's a good chance it will work.</p>
<p>Specifically, for <code>VectorProcess&lt;T, U, V&gt;</code>:</p>
<ul>
<li><code>T</code> is your resource type</li>
<li><code>U</code> is the parameter type that is sent by the process to any downstream components, and</li>
<li><code>V</code> is the parameter type that is sent to upstream components to request material</li>
</ul>
<p>Thus <code>VectorProcess&lt;Vector3, Vector3, f64&gt;</code> is a 1-in, 1-out process which handles a <code>T=Vector3</code>, and is passed downstream as a <code>U=Vector3</code>. However, when requesting the upstream Stock for material, this process sends a <code>V=f64</code> corresponding to the total quantity of desired material, and the stock responds with a <code>T=Vector3</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
