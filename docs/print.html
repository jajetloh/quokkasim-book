<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The QuokkaSim Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The QuokkaSim Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-quokkasim-book"><a class="header" href="#the-quokkasim-book">The QuokkaSim Book</a></h1>
<p>Welcome to the <strong>QuokkaSim Book</strong> – your guide to learning and mastering QuokkaSim, the Rust-based discrete-event simulation framework.</p>
<blockquote>
<p><strong>Note:</strong><br />
QuokkaSim is under <strong>very active</strong> development. Let JJ know if:</p>
<ul>
<li>You find mistakes, typos or missing information</li>
<li>You have ideas to contribute, or want to contribute in a more hands-on capacity</li>
<li>You're unsure if QuokkaSim is suitable for your use case. If it's not, let's discuss how it can be!</li>
</ul>
<p>If you are reading this, you probably already know how to contact me 😉 - JJ</p>
</blockquote>
<hr />
<h2 id="what-is-quokkasim"><a class="header" href="#what-is-quokkasim">What is QuokkaSim?</a></h2>
<p>QuokkaSim is a high-performance, event-driven simulation framework written in Rust, on top of the <a href="https://github.com/asynchronics/nexosim">NeXosim</a> simulation engine.</p>
<p>QuokkaSim is also:</p>
<ul>
<li>Open source</li>
<li>Permissively licensed (MIT License)</li>
<li>Memory-safe</li>
<li>Highly performant, via the NeXosim crate</li>
<li>Accessible to new simulation modellers and new Rust developers</li>
</ul>
<hr />
<h2 id="who-should-read-this-book"><a class="header" href="#who-should-read-this-book">Who should read this book?</a></h2>
<p>This book is written for:</p>
<ol>
<li>You</li>
<li>Some other people too</li>
</ol>
<hr />
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<p><strong>Why does QuokkaSim use Rust?</strong></p>
<ul>
<li>Building QuokkaSim in Rust means:
<ul>
<li>QuokkaSim can be free and open source under the MIT License.</li>
<li>QuokkaSim is highly performant (thanks to the <a href="https://github.com/asynchronics/nexosim">NeXosim</a> library).</li>
<li>Simulations built in QuokkaSim can benefit from the type safety, memory safety, and explicit error handling that is fundamental to Rust. This strictness minimises issues that arise as a simulation model scales and increases in complexity.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1-getting-started"><a class="header" href="#chapter-1-getting-started">Chapter 1: Getting Started</a></h1>
<p>Welcome to your first QuokkaSim simulation! In this chapter you will</p>
<ol>
<li>Create a new Rust project</li>
<li>Add QuokkaSim as a dependency</li>
<li>Write and run a minimal "hello world" simulation</li>
</ol>
<hr />
<h2 id="11-create-a-new-rust-project"><a class="header" href="#11-create-a-new-rust-project">1.1. Create a new Rust project</a></h2>
<p>If you don’t already have a project, open a terminal and run:</p>
<pre><code class="language-bash">cargo new hello‐quokkasim
cd hello‐quokkasim
</code></pre>
<p>This creates a fresh binary crate with <code>src/main.rs</code>.</p>
<h2 id="12-add-quokkasim-to-cargotoml"><a class="header" href="#12-add-quokkasim-to-cargotoml">1.2. Add QuokkaSim to Cargo.toml</a></h2>
<p>To add QuokkaSim as a dependency, use <code>cargo add quokkasim</code> or add the following to your <code>Cargo.toml</code> file before running <code>cargo fetch</code>:</p>
<pre><code class="language-toml">[dependencies]
quokkasim = "0.0.1"
</code></pre>
<h2 id="13-write-your-first-simulation"><a class="header" href="#13-write-your-first-simulation">1.3. Write your first Simulation</a></h2>
<p>In your <code>main.rs</code> file, paste in the following code at the top. This imports the required objects, and also creates our <code>ComponentModel</code> and <code>ComponentLogger</code> enums, which we will learn about later.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{error::Error, time::Duration};
use quokkasim::{define_model_enums, prelude::*}; 
use std::fs::create_dir_all;

define_model_enums! {
    pub enum ComponentModel {}
    pub enum ComponentModelAddress {}
    pub enum ComponentLogger {}
    pub enum ScheduledEvent {}
}

impl CustomComponentConnection for ComponentModel {
    fn connect_components(a: &amp;mut Self, b: &amp;mut Self, n: Option&lt;usize&gt;) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        match (a, b) {
            (a, b) =&gt; Err(format!("No component connection defined from {} to {} (n={:?})", a, b, n).into()),
        }
    }
}

impl CustomLoggerConnection for ComponentLogger { 
    type ComponentType = ComponentModel;
    fn connect_logger(a: &amp;mut Self, b: &amp;mut Self::ComponentType, n: Option&lt;usize&gt;) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        match (a, b, n) {
            (a, b, _) =&gt; Err(format!("No logger connection defined from {} to {} (n={:?})", a, b, n).into()),
        }
    }
}

impl CustomInit for ComponentModelAddress {
    fn initialise(&amp;mut self, simu: &amp;mut Simulation) -&gt; Result&lt;(), ExecutionError&gt; {
        let notif_meta = NotificationMetadata {
            time: simu.time(),
            element_from: "Init".into(),
            message: "Start".into(),
        };
        match self {
            _ =&gt; {
                Err(ExecutionError::BadQuery)
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Next we create the individual interactive components of our simulation</p>
<p align="center"><img src="images/fig-01.png" alt="Figure 1: Simulation Overview" /><p>
<p><code>Stock1</code> hold some quantity of material, which <code>Process1</code> moves at specific times, into <code>Stock2</code>. Add the following into the <code>main()</code> function to create these components, and to connect them together.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut stock1 = ComponentModel::VectorStockF64(
        VectorStock::new()
            .with_name("Stock1".to_string())
            .with_low_capacity(5.)
            .with_max_capacity(30.)
            .with_initial_vector(30.),
        Mailbox::new()
    );

    let mut process1 = ComponentModel::VectorProcessF64(
        VectorProcess::new()
            .with_name("Process1".to_string())
            .with_process_quantity_distr(Distribution::Constant(12.))
            .with_process_time_distr(Distribution::Constant(3.)),
        Mailbox::new()
    );
    let mut process_addr = process1.get_address();

    let mut stock2 = ComponentModel::VectorStockF64(
        VectorStock::new()
            .with_name("Stock2".to_string())
            .with_low_capacity(15.)
            .with_max_capacity(30.)
            .with_initial_vector(0.),
        Mailbox::new()
    );

    connect_components!(&amp;mut stock1, &amp;mut process1).unwrap();
    connect_components!(&amp;mut process1, &amp;mut stock2).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Next we'll add some <code>Logger</code> instances to report on what occurs during the simulation, and connect them to our Process and Stock components.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut stock_logger = ComponentLogger::VectorStockLoggerF64(VectorStockLogger::new("StockLogger".into()));
    let mut process_logger = ComponentLogger::VectorProcessLoggerF64(VectorProcessLogger::new("ProcessLogger".into()));

    connect_logger!(&amp;mut stock_logger, &amp;mut stock1).unwrap();
    connect_logger!(&amp;mut stock_logger, &amp;mut stock2).unwrap();
    connect_logger!(&amp;mut process_logger, &amp;mut process1).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Then we create our <code>Simulation</code> object <code>sim</code>, which controls the progression of the simulation.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut sim_builder = SimInit::new();
    sim_builder = register_component!(sim_builder, stock1);
    sim_builder = register_component!(sim_builder, process1);
    sim_builder = register_component!(sim_builder, stock2);

    let start_time = MonotonicTime::EPOCH;
    let mut simu = sim_builder.init(MonotonicTime::EPOCH).unwrap().0;
<span class="boring">}</span></code></pre></pre>
<p>We send and initialisation events, tell our simulation to run for an hour, and write the resulting logs to CSV files.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    process_addr.initialise(&amp;mut simu).unwrap();

    let end_time = start_time + Duration::from_secs(3600);
    simu.step_until(end_time).unwrap();

    let output_dir = "outputs/example_0";
    create_dir_all(&amp;output_dir).unwrap();
    process_logger.write_csv(output_dir).unwrap();
    stock_logger.write_csv(output_dir).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Our <code>main.rs</code> file is now complete (or refer to the Full Code below if you think you're missing something).</p>
<p>Use <code>cargo run</code> to run the simulation, and we have our logs in the <code>outputs/example_0</code> directory!</p>
<hr />
<h2 id="full-code"><a class="header" href="#full-code">Full Code</a></h2>
<pre><pre class="playground"><code class="language-rust no_run">use std::{error::Error, time::Duration};
use quokkasim::{define_model_enums, prelude::*}; 
use std::fs::create_dir_all;

define_model_enums! {
    pub enum ComponentModel {}
    pub enum ComponentModelAddress {}
    pub enum ComponentLogger {}
    pub enum ScheduledEvent {}
}

impl CustomComponentConnection for ComponentModel {
    fn connect_components(a: &amp;mut Self, b: &amp;mut Self, n: Option&lt;usize&gt;) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        match (a, b) {
            (a, b) =&gt; Err(format!("No component connection defined from {} to {} (n={:?})", a, b, n).into()),
        }
    }
}

impl CustomLoggerConnection for ComponentLogger { 
    type ComponentType = ComponentModel;
    fn connect_logger(a: &amp;mut Self, b: &amp;mut Self::ComponentType, n: Option&lt;usize&gt;) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        match (a, b, n) {
            (a, b, _) =&gt; Err(format!("No logger connection defined from {} to {} (n={:?})", a, b, n).into()),
        }
    }
}

impl CustomInit for ComponentModelAddress {
    fn initialise(&amp;mut self, simu: &amp;mut Simulation) -&gt; Result&lt;(), ExecutionError&gt; {
        let notif_meta = NotificationMetadata {
            time: simu.time(),
            element_from: "Init".into(),
            message: "Start".into(),
        };
        match self {
            _ =&gt; {
                Err(ExecutionError::BadQuery)
            }
        }
    }
}

fn main() {
    
    /*
     * Create components
     */
    let mut stock1 = ComponentModel::VectorStockF64(
        VectorStock::new()
            .with_name("Stock1".to_string())
            .with_low_capacity(5.)
            .with_max_capacity(30.)
            .with_initial_vector(30.),
        Mailbox::new()
    );

    let mut process1 = ComponentModel::VectorProcessF64(
        VectorProcess::new()
            .with_name("Process1".to_string())
            .with_process_quantity_distr(Distribution::Constant(12.))
            .with_process_time_distr(Distribution::Constant(3.)),
        Mailbox::new()
    );
    let mut process_addr = process1.get_address();

    let mut stock2 = ComponentModel::VectorStockF64(
        VectorStock::new()
            .with_name("Stock2".to_string())
            .with_low_capacity(15.)
            .with_max_capacity(30.)
            .with_initial_vector(0.),
        Mailbox::new()
    );

    connect_components!(&amp;mut stock1, &amp;mut process1).unwrap();
    connect_components!(&amp;mut process1, &amp;mut stock2).unwrap();

    /*
     * Create loggers
     */
    let mut stock_logger = ComponentLogger::VectorStockLoggerF64(VectorStockLogger::new("StockLogger".into()));
    let mut process_logger = ComponentLogger::VectorProcessLoggerF64(VectorProcessLogger::new("ProcessLogger".into()));

    connect_logger!(&amp;mut stock_logger, &amp;mut stock1).unwrap();
    connect_logger!(&amp;mut stock_logger, &amp;mut stock2).unwrap();
    connect_logger!(&amp;mut process_logger, &amp;mut process1).unwrap();

    /*
     * Build simulation
     */
    let mut sim_builder = SimInit::new();
    sim_builder = register_component!(sim_builder, stock1);
    sim_builder = register_component!(sim_builder, process1);
    sim_builder = register_component!(sim_builder, stock2);

    let start_time = MonotonicTime::EPOCH;
    let mut simu = sim_builder.init(MonotonicTime::EPOCH).unwrap().0;

    /*
     * Run simulation
     */
    process_addr.initialise(&amp;mut simu).unwrap();

    let end_time = start_time + Duration::from_secs(3600);
    simu.step_until(end_time).unwrap();

    let output_dir = "outputs/example_0";
    create_dir_all(&amp;output_dir).unwrap();
    process_logger.write_csv(output_dir).unwrap();
    stock_logger.write_csv(output_dir).unwrap();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-a-conceptual-overview"><a class="header" href="#chapter-2-a-conceptual-overview">Chapter 2: A Conceptual Overview</a></h1>
<p>In this chapter, we cover the main concepts defined and used in QuokkaSim, and how to map your real-world scenario into these concepts, which we will later cover how to implement as a model in Chapter 3.</p>
<p>This chapter increases in theoretical depth as it progresses. If you are new to simulations, up to Chapter 2.3. is recommended.</p>
<p>Chapter 2.4. is recommended if you are needing to build more customised components and structures than what QuokkaSim provides out-of-the-box.</p>
<p>After reading this chapter you should:</p>
<ul>
<li>Understand QuokkaSim as a <strong>Discrete Event Simulation</strong> framework, and the contexts in which such a DES framework is applicable</li>
<li>Understand the core concepts of <strong>Resources, Stocks and Processes</strong>, and examples of how real-world scenarios can be mapped to these concepts</li>
<li>Have a basic understanding of the <strong>interactions</strong> between Processes and Stocks, via the exchange of Resources, and how these <strong>events for a process are triggered internally and externally</strong></li>
<li>Be familiar with the concepts of <strong>Resource conservation</strong>, and how this relates to Sources, Sink and other types of Process</li>
<li>Be familiar with the classification of Splitters and Combiners as <strong>AND-like</strong>, <strong>OR-like</strong> or <strong>a combination of both</strong>.</li>
</ul>
<hr />
<h2 id="21-discrete-event-simulation-and-the-schedule"><a class="header" href="#21-discrete-event-simulation-and-the-schedule">2.1. Discrete Event Simulation and the Schedule</a></h2>
<p>Simulations answer "what-if" questions, most commonly about what is the result of a set of initial conditions, rules, and controls.</p>
<p>One approach is to approximate the continuous flow of time, by simulating the system at regular time-steps. This is a good regime for modelling continuous processes, such as:</p>
<ul>
<li>Movement of a pendulum under gravity,</li>
<li>Temperature of a room over a day, or</li>
<li>Stresses and fatigue in a beam under repeated loads</li>
</ul>
<p>A time-stepped approach is good in these cases because</p>
<ol>
<li>There are well-defined equations for how quantities of interest change over time</li>
<li>The length of the time-step can be adjusted based on how precise results need to be (and in fact, some approaches <a href="https://en.wikipedia.org/wiki/Adaptive_step_size">use an adaptive, changing time-step</a>)</li>
</ol>
<p>In each of the above situations, quantities of interest change continuously over time, so we need to re-calculate the state of the system often to ensure we're capturing any important changes.</p>
<p>However, many systems don't deal with continuous quantities, or have important behaviour happening continuously over time, for example:</p>
<ul>
<li>Traffic flow through a traffic light,</li>
<li>Preparing drinks at a cafe, or</li>
<li>Car assembly at a factory</li>
</ul>
<p>In these situations, it can be very inefficient to update every component of the system at every timestep. A better approach here is to only update the system at the exact timesteps where something will happen! This is the approach taken in Discrete Event Simulation.</p>
<p>In Discrete Event Simulation, an ordered schedule of events is maintained, and time jumps forward to the next event, which in turns can schedule more events.</p>
<h2 id="22-resources-stocks-and-processes"><a class="header" href="#22-resources-stocks-and-processes">2.2. Resources, Stocks and Processes</a></h2>
<p>TL;DR:</p>
<ul>
<li>Resources are the quantities of stuff that we're interested in the movement of</li>
<li>Stocks are entities which passively hold resources</li>
<li>Processes are entities which actively move or transform resources, and can hold some resources as part of processing</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Example Use Case</th><th>Resource</th><th>Stocks</th><th>Processes</th></tr></thead><tbody>
<tr><td>Water tanks connected by pipes</td><td>Litres of water</td><td>Tanks, resevoirs, pipes</td><td>Valves</td></tr>
<tr><td>Trucking of Ore</td><td>Tonnes of ore</td><td>Stockpiles of ore</td><td>Trucks, conveyors, reclaiming equipment</td></tr>
<tr><td>Customers in a Cafe</td><td>Customers</td><td>Queue for ordering, waiting area</td><td>Taking orders, serving drinks</td></tr>
</tbody></table>
</div>
<h2 id="23-detailed-material-flow-customers-in-a-cafe"><a class="header" href="#23-detailed-material-flow-customers-in-a-cafe">2.3. Detailed Material Flow: Customers in a Cafe</a></h2>
<p><strong>Time = Initial</strong></p>
<p align="center"><img src="images/barista_1.svg" alt="Barista 1" /><p>
We have a stock representing a queue of customers, which is processed by a barista who takes drink orders, before customers go into another queue to wait for their drink. The starting point of the simulation is shown in the diagram, with 3 people in line, and 1 person waiting for their drink.
<p>Remember that Discrete Event Simulations relies on scheduled events triggering more events. There are no events at the start of the simulation, so we kick-start the simulation at the start by telling our <em>Barista taking orders</em> Process to update itself.</p>
<p><strong>Time = 0:00</strong></p>
<p align="center"><img src="images/barista_2.svg" alt="Barista 2" /><p>
<p>The barista can only process a customer if a customer is in the queue, and if there is sufficient room in the waiting area (or perhaps just to not overwhelm the baristas who are making the drinks).</p>
<p>First, the process retrieves the current state of the upstream stock (<em>Queued Customers</em>) and downstream stock (<em>Waiting for drinks</em>). For now, stocks can have one of three states: Empty, Normal and Full.</p>
<p><em>Queued customers</em> is Full and <em>Waiting for drinks</em> is Normal. In this case, the barista can take an order, so the process seizes the front-most customer from the queue, and schedules a new event to occur in 30 seconds, when the ordering is complete.</p>
<p><strong>Time = 0:30</strong></p>
<p align="center"><img src="images/barista_3.svg" alt="Barista 3" /><p>
<p>30 seconds later, the event triggers <em>Barista taking orders</em> is prompted to update itself again. This time, it first moves Customer B moves into the <em>Waiting for drinks</em> stock, before checking upstream and downstream states again. This time both states are <em>Normal</em>, in which case the process seizes the next customer and repeats.</p>
<p align="center"><img src="images/barista_4.svg" alt="Barista 4" /><p>
<p><strong>Time = 1:00</strong></p>
<p align="center"><img src="images/barista_5.svg" alt="Barista 5" /><p>
<p><em>Barista taking orders</em> is again triggered to update its state, and moves C into <em>Waiting for drinks</em>. This time the upstream and downstream states are <em>Normal</em> and <em>Full</em>. Because downstream is full, we do not process the next customer, and instead wait until we are triggered to update again.</p>
<p><strong>Time = 1:15</strong></p>
<p align="center"><img src="images/barista_6.svg" alt="Barista 6" /><p>
<p><em>Waiting for drinks</em> has reduced from 3 people to 1 person, meaning its state has changed from <em>Full</em> to <em>Normal</em>. This change of state triggers any upstream or downstream processes to update, meaning that <em>Barista taking orders</em> is triggered to update.</p>
<p><em>Barista taking orders</em> checks both upstream and downstream state again, finds both are <em>Normal</em>, so then begins processing D.</p>
<h2 id="24-a-taxonomy-of-processes"><a class="header" href="#24-a-taxonomy-of-processes">2.4. A Taxonomy of Processes</a></h2>
<p>In QuokkaSim, Processes are at the heart of all dynamic behaviours. We wish to make our processes as flexible as possible to allow us to test whatever we wish. However, we also wish to have as minimal of a set of these processes as possible, to minimise complexity and the mental burden of reasoning about them. With a small set of well-defined components, modellers who are new to QuokkaSim are able to pick up the framework quickly, and effectively translate real-world scenarios to a model representation.</p>
<p>Note that we are not saying you have to follow this taxonomy or these concepts. You are free to create your own components suited to your use cases. If you have a case that isn't well suited to using our components, we'd like to hear about it! If such use cases are common, we will consider adding them as components in QuokkaSim directly.</p>
<div class="table-wrapper"><table><thead><tr><th>Concept</th><th># Inputs</th><th># Outputs</th><th>Conserves resources?</th></tr></thead><tbody>
<tr><td>Simple Process</td><td>1</td><td>1</td><td>✅ Yes</td></tr>
<tr><td>Source</td><td>0</td><td>1</td><td>❌ Creates resources</td></tr>
<tr><td>Sink</td><td>1</td><td>0</td><td>❌ Destroys resources</td></tr>
<tr><td>Combiner</td><td>N</td><td>1</td><td>✅ Yes</td></tr>
<tr><td>Splitter</td><td>1</td><td>N</td><td>✅ Yes</td></tr>
</tbody></table>
</div>
<h3 id="241-resource-conservation"><a class="header" href="#241-resource-conservation">2.4.1. Resource Conservation</a></h3>
<p>In most systems, there can be a natural sense of conservation, or of balance. For example:</p>
<ul>
<li>In a transport simulation, a <code>Car { car_id: u32, make: String, model: String }</code> resource should not be created or destroyed in most processes. Cars are a conserved quantity in this context.</li>
<li>In a manufacturing simulation where we track the parts of a car through the manufacturing process via a vector of masses <code>ProtoCar { assembled_kg: f64, loose_tyres_kg: f64, loose_engine_kg: f64 }</code>, the total mass of parts through our system should be conserved, except where new parts are introduced into the system or the assembled car is removed from the system. However, the individual components like <code>loose_tyres_kg</code> are not conserved, and can be transformed into <code>assembled_kg</code> subject to the total mass being conserved.</li>
<li>In an ore crushing operation, where a crusher processes large rocks into smaller pieces, we may use a vector of masses <code>Ore { small: f64, medium: f64, large: f64 }</code>. The crusher may transform large pieces into small or medium pieces, but the total mass is conserved.</li>
</ul>
<p>By having most processes conserving resources, the key activities of resource creation and destruction are separated out into their own proceses, which can be monitored with more scrutiny than other processes.</p>
<h3 id="242-types-of-combiners-and-splitters"><a class="header" href="#242-types-of-combiners-and-splitters">2.4.2. Types of Combiners and Splitters</a></h3>
<p>Combiners and Splitters can be further classified by whether or not inputs/outputs are <strong>AND-like (combinations)</strong> or <strong>XOR-like (choices)</strong> - or a combination of both.</p>
<p>What does this mean? Let's think through a couple of examples of combiners first.</p>
<p align="center"><img src="images/combiner_xor.svg" alt="XOR Combiner" /><p>
<p>Let's say you're a delivery driver. At your disposal is a number of cars, vans and trucks. Each distinct set of vehicle is a stock, but you can only choose to take from one of these stocks at this time. This is an <strong>XOR-like</strong> combiner process, as you must choose a car <strong>or</strong> a van <strong>or</strong> a truck - where <strong>or</strong> is an <strong>exclusive or</strong> (XOR).</p>
<p align="center"><img src="images/combiner_and.svg" alt="AND Combiner" /><p>
<p>On the other hand, let's say you are combining the ingredients for a cake - butter, sugar, eggs and flour. In this case, we want a combination of all four in a specific ratio, not an exclusive choice of one of them. In general we want a <strong>combination</strong> of some quantity of butter <strong>and</strong> sugar <strong>and</strong> eggs <strong>and</strong> flour (though in an edge case some quantities may be 0), thus this is a <strong>AND-like</strong> combiner process.</p>
<p>An example of a more general combiner which has both XOR and AND elements is the above cake batter example, but where you have to choose exclusively from different types of sugar like White Sugar, Brown Sugar and Honey.</p>
<p>A similar breakdown can be made of Splitters. XOR-like splitters push material into one stock at a time. AND-like splitters generally push material into all downstream stocks at once. A more general splitter can push into multiple, but have some exclusivity constraints.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-building-your-simulation-model"><a class="header" href="#chapter-3-building-your-simulation-model">Chapter 3: Building your Simulation Model</a></h1>
<p>Now that we've understood the core concepts used by QuokkaSim, let's look at how we assemble a simulation model from scratch.</p>
<ol>
<li>Definitions</li>
<li>Model Assembly</li>
<li>Execution and Logging</li>
</ol>
<p>This chapter will explain the purpose of the specific structs, enums, traits and macros provided by QuokkaSim. Code snippets are also used, but are only for demonstrating individual concepts. Numerous full examples of working simulations can be found in <a href="examples.html">Chapter 4: Examples</a>.</p>
<hr />
<h2 id="31-definitions"><a class="header" href="#31-definitions">3.1. Definitions</a></h2>
<h3 id="311-enums"><a class="header" href="#311-enums">3.1.1. Enums</a></h3>
<p>A set of four enums comprise the core of QuokkaSim, and these are declared within the <strong><code>define_model_enums!</code></strong> macro like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_model_enums! {
    pub enum ComponentModel {}
    pub enum ComponentModelAddress {}
    pub enum ComponentLogger {}
    pub enum ScheduledEvent {}
}
<span class="boring">}</span></code></pre></pre>
<p>Though the enums look empty, <code>define_model_enums!</code> endows each of them with all of QuokkaSim's pre-built components, so in reality ComponentModel acts more like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ComponentModel {
    VectorStockF64(VectorStock&lt;f64&gt;, Mailbox&lt;VectorStock&lt;f64&gt;&gt;),
    VectorProcessF64(VectorProcess&lt;f64&gt;, Mailbox&lt;VectorProcess&lt;f64&gt;&gt;),
    ...
}
<span class="boring">}</span></code></pre></pre>
<p><strong><code>ComponentModel</code></strong> is an enum containing all elements we wish to take part in the simulation. Specifically, it must contain all concrete stocks and processes we wish to use. By ensuring that all components are contained as variants in <code>ComponentModel</code>, this allows us to later perform much more powerful operations across all components, such as being able to construct a simulation model from a JSON or TOML file.</p>
<p>Each variant contains both the instance of the component, as well as a <strong><code>Mailbox</code></strong> for the variant. The <code>Mailbox</code> a NeXosim struct, and is the single point which receives all inbound communications to the component.</p>
<p>If we wish to use our own custom components, we can register them as variants in <code>ComponentModel</code> like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_model_enums! {
    pub enum ComponentModel {
        MyNewComponent(MyNewComponentStruct, Mailbox&lt;MyNewComponentStruct&gt;),
    }
    pub enum ComponentModelAddress {}
    pub enum ComponentLogger {}
    pub enum ScheduledEvent {}
}
<span class="boring">}</span></code></pre></pre>
<p><strong><code>ComponentModelAddress</code></strong> is an enum containing the <strong><code>Address</code></strong> of all our components. An <code>Address</code> is simply a reference to a specific <code>Mailbox</code>. While only a single <code>Mailbox</code> exists per component, we can get the <code>Address</code> from the <code>Mailbox</code> and pass ownership and clone as we please. We will use the <code>Address</code> to make calls to kick-start the model execution and also to schedule fixed events.</p>
<p>If we wish to use our own custom components, after defining them in <code>ComponentModel</code>, the <code>define_model_enums!</code> macro creates the corresponding variant in <code>ComponentModelAddress</code>, which looks like this. We don't need to manually add them to <code>ComponentModelAddress</code>!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ComponentModelAddress {
    VectorStockF64(Address&lt;VectorStock&lt;f64&gt;&gt;),
    VectorProcessF64(Address&lt;VectorProcess&lt;f64&gt;&gt;),
    ...
    MyNewComponent(Address&lt;MyNewComponentStruct&gt;),
}
<span class="boring">}</span></code></pre></pre>
<p><strong><code>ComponentLogger</code></strong> is an enum containing all unique structs that we wish to be able to collect logs in, and export logs from. QuokkaSim comes pre-built with one type of logger for each standard stock, and each standard process - meaning that all processes (simple processes, splitters, and combiners) for the <code>Vector3</code> resource, share the <code>VectorProcessLoggerVector3</code> logger, and thus can all export logs into a single file if desired.</p>
<p>Our enums here must contain concrete types (no generic type parameters!), so if we are using our own custom resource, or creating an entirely new <code>Logger</code> struct, we must register them like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_model_enums! {
    pub enum ComponentModel {
        MyNewComponent(MyNewComponentStruct, Mailbox&lt;MyNewComponentStruct&gt;),
    }
    pub enum ComponentModelAddress {}
    pub enum ComponentLogger {
        MyNewVectorLogger(VectorProcessLogger&lt;MyNewResource&gt;), // e.g. adding a new vector resource
        MyNewCustomLogger(MyNewCustomLoggerStruct),            // e.g. adding a new type of Logger
    }
    pub enum ScheduledEvent {}
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, <strong><code>ScheduledEvent</code></strong> contains all the ways for us to push certain events at select times during the model run, such as a capacity change or a change of distributions. <code>ScheduledEvent</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ScheduledEvent {
    SetMaxCapacity(f64),
    SetProcessTime(DistributionConfig),
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Note that the variants of <code>ScheduledEvent</code> aren't tied to a single type of component. This is because we are able to later define for each component, what each of these events means.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;chapter_3_enum_quiz&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;17e96e10-fa47-4f69-9d65-63e8ece13ba3&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;ComponentModel&quot;,&quot;answerIndex&quot;:0},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;ComponentModelAddress&quot;,&quot;ComponentLogger&quot;,&quot;ScheduledEvent&quot;],&quot;prompt&quot;:&quot;Which enum must contain all Processes and Stocks to be used in the model?&quot;}},{&quot;context&quot;:&quot;Components need to be registered in `ComponentModel`, but this automatically creates a corresponding variant in `ComponentModelAddress`. You will also likely want to view logs from the new component, thus a new Logger will also need to be added to `ComponentLogger`.&quot;,&quot;id&quot;:&quot;6428c2ce-e43a-4e10-bfac-e54b4857f57c&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;Manually adding a new variant to `ComponentModel`&quot;,&quot;Manually adding a new variant to `ComponentLogger`&quot;],&quot;answerIndex&quot;:0},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Manually adding a new variant to `ComponentModelAddress`&quot;],&quot;prompt&quot;:&quot;After creating a struct for a custom component, what else needs to happen in `define_model_enums!` to allow it to be used within QuokkaSim?&quot;}}]}"></div>
<h3 id="312-macros"><a class="header" href="#312-macros">3.1.2. Macros</a></h3>
<p>In addition to defining enums, the <code>define_model_enums!</code> macro also defines a number of functions (which are actually macros) that we will use to assemble our model. The fact they are defined within the <code>define_model_enums!</code> call means that they are able to work with any custom components and loggers added, and also mean they do not have to be imported via <code>use</code> like <code>define_model_enums!</code>.</p>
<p>The four functions defined here are:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn connect_components!(
    comp1: &amp;mut ComponentModel,
    comp2: &amp;mut ComponentModel,
    n: Option&lt;usize&gt; = None
) { ... }

fn connect_logger!(
    logger: &amp;mut ComponentLogger,
    comp: &amp;mut ComponentModel,
    n: Option&lt;usize&gt; = None
) { ... }

fn register_component!(
    sim_init: SimInit,
    comp: ComponentModel
) -&gt; SimInit { ... }

fn create_scheduled_event!(
    &amp;mut Scheduler,
    MonotonicTime,
    ScheduledEvent,
    ComponentModelAddres,
    &amp;mut DistributionFactory
) { ... }
<span class="boring">}</span></code></pre></pre>
<p><strong><code>connect_components!(&amp;mut comp1, &amp;mut comp2)</code></strong> defines a directional relationship, with <code>comp1</code> upstream and <code>comp2</code> downstream - meaining in this connection, resources flow from <code>comp1</code> to <code>comp2</code>.</p>
<p>If <code>comp1</code> is a splitter, this means there are multiple outputs from <code>comp1</code> and we must define which output we wish to connect. <strong><code>connect_components!(&amp;mut comp1, &amp;mut comp2, n)</code></strong> is how we do this, with <code>n</code> being the index of the output from <code>comp1</code>.</p>
<p>If <code>comp2</code> is a combiner, we have the same problem on the opposite side, where we need to define which input of the combiner we are connecting to. In this case we still use <strong><code>connect_components!(&amp;mut comp1, &amp;mut comp2, n)</code></strong> but <code>n</code> refers to the index of the input for <code>comp2</code>.</p>
<p><strong><code>connect_logger!(&amp;mut logger, &amp;mut comp)</code></strong> connects a logger to a component. This means that the logger is notified any time the component emits a log from the associated output port. All pre-built QuokkaSim components only have a single output port, though it is possible to create components with multiple ports, with each serving a different purpose.</p>
<p><strong><code>register_component!(sim_init, comp)</code></strong> is used to add the instantiated component to the simulation model. This call passes ownership of the component to the <code>SimInit</code> instance. Due to some subtleties of the <code>SimInit</code> struct, a call to this macro also takes ownership of <code>SimInit</code>, and thus must also return <code>SimInit</code>. This means usage should always look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>sim_builder = register_component!(sim_builder, process);
<span class="boring">}</span></code></pre></pre>
<p><strong><code>create_scheduled_event!</code></strong> creates an event in the global <code>Scheduler</code>, which will be triggered at the provided time (this time must be in the future of the current simulation time).</p>
<div class="quiz-placeholder" data-quiz-name="&quot;chapter_3_macro_quiz&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The flow of resources is from the first to second argument, meaning either `stock` pushes or `process` pulls. Stocks are passive and processes are active, so `process` pulling resources in is a more accurate description.&quot;,&quot;id&quot;:&quot;fbb641a5-72de-4574-b816-33a0c706b728&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Allow `process` to pull resources from `stock`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Allow `stock` to pull resources from `process`&quot;,&quot;Allow `stock` to push resources into `process`&quot;,&quot;Allow `process` to push resources into `stock`&quot;],&quot;prompt&quot;:&quot;What does this code do?\n```rust\nconnect_components!(&amp;mut stock, &amp;mut process);\n```\n&quot;}},{&quot;context&quot;:&quot;`connect_logger!` takes a mutable reference to both `logger` and `process` to set up the connection, instead of taking ownership.&quot;,&quot;id&quot;:&quot;79e110b9-7538-42dc-9ff1-47416ea4f050&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`connect_logger!(&amp;mut logger, &amp;mut process)`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`connect_logger!(logger, process);`&quot;,&quot;`connect_logger!(logger, &amp;mut process);`&quot;],&quot;prompt&quot;:&quot;Which is a valid call to `connect_logger`?&quot;}}]}"></div>
<h2 id="32-model-assembly"><a class="header" href="#32-model-assembly">3.2. Model Assembly</a></h2>
<h2 id="33-choose-your-data-structures"><a class="header" href="#33-choose-your-data-structures">3.3. Choose Your Data Structures</a></h2>
<p>QuokkaSim supports the following Resource types out-of-the-box:</p>
<ul>
<li>
<p><strong>Vectors (f64)</strong></p>
<ul>
<li>Use when your quantity of interest is a single number that can take a continuous range of values.</li>
<li>e.g. For modelling power consumption, your <code>f64</code> can represent Energy in Joules</li>
<li>e.g. For modelling material flow, your <code>f64</code> can represent payload mass in kg</li>
<li><code>VectorProcess&lt;f64&gt;</code>, <code>VectorStock&lt;f64&gt;</code> and other similar components can be used out-of-the-box</li>
</ul>
</li>
<li>
<p><strong>Vectors (Vector3)</strong></p>
<ul>
<li>Use when your quantity of interest has up to three independent components of interest</li>
<li>e.g. For modelling nutrient consumption in crops, your <code>Vector3</code> can represent masses of Nitrogen, Phsophorous and Potassium elements</li>
<li>e.g. For modelling an iron ore mine, your <code>Vector3</code> can represent Iron, Silica and other elements by mass</li>
<li><code>VectorProcess&lt;Vector3&gt;</code>, <code>VectorStock&lt;Vector3&gt;</code> and other similar components can be used out-of-the-box</li>
</ul>
</li>
<li>
<p><strong>Sequences (String)</strong></p>
<ul>
<li>Use when your quantity of interest experiencing queuing or other behaviours dependent on other relative ordering</li>
<li>e.g. For modelling a queue of vehicles, your <code>String</code> can be a unique identifier for a car</li>
</ul>
</li>
</ul>
<p>Your simulation can use a combination of these, or you can create your own resources if this suits your use case better (e.g. if you prefer a vector with named entries for readability, instead of referencing components by index).</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Vectors (f64)</th><th>Vectors (Vector3)</th><th>Sequences (String)</th></tr></thead><tbody>
<tr><td>Resource</td><td><code>f64</code></td><td><code>Vector3</code></td><td><code>String</code></td></tr>
<tr><td>Stock</td><td><code>VectorStock&lt;f64&gt;</code></td><td><code>VectorStock&lt;Vector3&gt;</code></td><td><code>SequenceStock&lt;String&gt;</code></td></tr>
<tr><td>Process (1-in, 1-out)</td><td><code>VectorProcess&lt;f64, f64, f64&gt;</code></td><td><code>VectorProcess&lt;Vector3, Vector3, f64&gt;</code></td><td><code>SequenceProcess&lt;Option&lt;String&gt;&gt;</code></td></tr>
<tr><td>Process (N-in, 1-out)</td><td><code>VectorCombiner&lt;f64, f64, f64, const M: usize&gt;</code></td><td><code>VectorCombiner&lt;Vector3, Vector3, f64, const M: usize&gt;</code></td><td>TBC</td></tr>
<tr><td>Process (1-in, N-out)</td><td><code>VectorSplitter&lt;f64, f64, f64, const N: usize&gt;</code></td><td><code>VectorSplitter&lt;Vector3, Vector3, f64, const N: usize&gt;</code></td><td>TBC</td></tr>
<tr><td>Process (0-in, 1-out)</td><td><code>VectorSource&lt;...&gt;</code></td><td><code>VectorSource&lt;...&gt;</code></td><td>TBC</td></tr>
<tr><td>Process (1-in, 0-out)</td><td><code>VectorSink&lt;...&gt;</code></td><td><code>VectorSink&lt;...&gt;</code></td><td>TBC</td></tr>
<tr><td>Example use case</td><td>Water tanks</td><td>Ore movements (using a vector to track elemental composition)</td><td>Customers at a Cafe</td></tr>
</tbody></table>
</div>
<p><strong>Why so many generic type parameters?</strong></p>
<p>The pre-defined generic structs <code>VectorProcess</code>, <code>SequenceStock</code> etc. can be used for any resource your simulation requires - as long as your resource satisfies all trait requirements. These requirements are checked at compiled time by the compiler, so if your code compiles, there's a good chance it will work.</p>
<p>Specifically, for <code>VectorProcess&lt;T, U, V&gt;</code>:</p>
<ul>
<li><code>T</code> is your resource type</li>
<li><code>U</code> is the parameter type that is sent by the process to any downstream components, and</li>
<li><code>V</code> is the parameter type that is sent to upstream components to request material</li>
</ul>
<p>Thus <code>VectorProcess&lt;Vector3, Vector3, f64&gt;</code> is a 1-in, 1-out process which handles a <code>T=Vector3</code>, and is passed downstream as a <code>U=Vector3</code>. However, when requesting the upstream Stock for material, this process sends a <code>V=f64</code> corresponding to the total quantity of desired material, and the stock responds with a <code>T=Vector3</code>.</p>
<h2 id="34-the-core-enums"><a class="header" href="#34-the-core-enums">3.4. The Core Enums</a></h2>
<p>At the beginning of all the example simulations is a section that looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_model_enums! {
    pub enum ComponentModel {}
    pub enum ComponentLogger {}
    pub enum ComponentInit {}
}

impl CustomComponentConnection for ComponentModel {
    fn connect_components(a: &amp;mut Self, b: &amp;mut Self, n: Option&lt;usize&gt;) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        match (a, b) {
            (a, b) =&gt; Err(format!("No component connection defined from {} to {} (n={:?})", a, b, n).into()),
        }
    }
}

impl CustomLoggerConnection for ComponentLogger { 
    type ComponentType = ComponentModel;
    fn connect_logger(a: &amp;mut Self, b: &amp;mut Self::ComponentType, n: Option&lt;usize&gt;) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        match (a, b, n) {
            (a, b, _) =&gt; Err(format!("No logger connection defined from {} to {} (n={:?})", a, b, n).into()),
        }
    }
}

impl CustomInit for ComponentInit {
    fn initialise(&amp;mut self, simu: &amp;mut Simulation) -&gt; Result&lt;(), ExecutionError&gt; {
        let notif_meta = NotificationMetadata {
            time: simu.time(),
            element_from: "Init".into(),
            message: "Start".into(),
        };
        match self {
            _ =&gt; {
                Err(ExecutionError::BadQuery)
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Let's break down what's going on here</p>
<p><code>define_model_enums!</code> is a macro provided by QuokkaSim, which is used to help define a number of key Enums that are required. In our examples for clarity they are all named <code>ComponentModel</code>, <code>ComponentLogger</code> and <code>ComponentInit</code> respectively. You are able to choose your own names for each in the body of the macro call, but note the order that they are specified determines the role that each enum plays.</p>
<ul>
<li>
<p><code>ComponentModel</code> is an Enum whose variants are all possible Stocks and Processes in our model. The <code>define_model_enums!</code> macro populates this enum with all of QuokkaSim's pre-built components (e.g. <code>VectorProcessF64(f64)</code>, <code>SequenceStockString(SequenceStock&lt;String&gt;)</code>).</p>
<p>If we have our own custom-defined components, we can add them to this enum to register them as a usable component.</p>
</li>
<li>
<p><code>ComponentLogger</code> is an Enum whose variants are all possible objects that are able to collect logs from our components, and export these logs.</p>
<p>If we have our own custom-defined loggers, we can add them to this enum to register them as a usable logger.</p>
</li>
<li>
<p><code>ComponentInit</code> is an Enum whose variants are all possible ways that objects should be initialised after model creation, but before the first event.</p>
<p>If we have our own custom initialisations (for our own components, or custom initialisations for existing components), we can add them to this enum to register them as a usable initialisation.</p>
</li>
</ul>
<p>In addition to these enums, a number of special function macros are also defined in <code>define_model_enums</code>.</p>
<ul>
<li>
<p><code>connect_components!</code> is used to define a connection between two components - typically a Stock and Process, or Process to Stock. In the case where a Process has multiple upstream or downstream stocks, an additional parameter is required to determine the specific upstream or downstream stock that is meant.</p>
</li>
<li>
<p><code>connect_logger!</code> is used to define a connection between a component and a logger.</p>
</li>
<li>
<p><code>register_component!</code> is used to add the constructed component to the model execution engine.</p>
</li>
</ul>
<hr />
<p>After <code>define_model_enums!</code> are a number of trait implementations. These trait implementations are how we define the details of what any sort of 'connection' means. Note that the methods implemented in t hese traits have the same name as the function macros defined in <code>define_model_enums</code>. This is because each of our functions here are called within the respective function macros if a pre-defined implementation does not exist for the enum variants passed into the function.</p>
<script type="text/javascript" src="quiz\quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz\style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4-examples"><a class="header" href="#chapter-4-examples">Chapter 4: Examples</a></h1>
<p>A number of example simulations exist to act as a reference for how to apply the concepts covered in this guide, in practice:</p>
<table>
<thead>
<tr>
    <td>Example Name</td>
    <td>Description</td>
    <td>Concepts Demonstrated</td>
</tr>
</thead>
<tbody>
<tr>
    <td><a href="https://github.com/jajetloh/quokkasim/blob/main/quokkasim_examples/src/bin/material_blending.rs">material_blending.rs</a></td>
    <td>Model of a stockyard with Reclaimers to remove material from multiple stockpiles, and a Stacker to add material to multiple stockpiles.</td>
    <td class="badge-container">
        <span class="badge">Pre-built components</span>
        <span class="badge">Vector Resource (Vector3)</span>
        <span class="badge">Splitters and Combiners</span>
    </td>
</tr>
<tr>
    <td><a href="https://github.com/jajetloh/quokkasim/blob/main/quokkasim_examples/src/bin/discrete_queue.rs">discrete_queue.rs</a></td>
    <td>Basic example demonstrating use of a Sequence resource of Strings. Processes and stocks are arranged in infinite loop.</td>
    <td class="badge-container">
        <span class="badge">Pre-built components</span>
        <span class="badge">Sequence Resource (String)</span>
        <span class="badge">Distribution Sampling</span>
    </td>
</tr>
<tr>
    <td><a href="https://github.com/jajetloh/quokkasim/blob/main/quokkasim_examples/src/bin/iron_ore.rs">iron_ore.rs</a></td>
    <td>Processes involving an Iron Ore resource, which tracks elemental mass composition, and composition by mineral types.</td>
    <td class="badge-container">
        <span class="badge">Custom vector resource</span>
        <span class="badge">Distribution Sampling</span>
    </td>
</tr>
</tbody>
</table>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
